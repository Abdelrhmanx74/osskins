// This file is a placeholder to re-export functionality from the injection module
// All actual functionality has been moved to the injection/ module directory

// Define Windows-specific constants at the module level
#[cfg(target_os = "windows")]
const CREATE_NO_WINDOW: u32 = 0x08000000;

// Add overlay cache to optimize injection performance
pub static OVERLAY_CACHE: Lazy<Arc<Mutex<OverlayCache>>> = Lazy::new(|| {
    Arc::new(Mutex::new(OverlayCache::new()))
});

// Structure to cache pre-built overlays
#[derive(Debug, Default)]
pub struct OverlayCache {
    // Map mod directory hash to pre-built overlay directory
    overlays: HashMap<String, (PathBuf, Instant)>,
    // Last time the cache was cleaned up
    last_cleanup: Option<Instant>,
}

impl OverlayCache {
    // Create a new empty cache
    pub fn new() -> Self {
        Self {
            overlays: HashMap::new(),
            last_cleanup: None,
        }
    }
    
    // Generate a hash key for the set of mods
    fn generate_hash(&self, mods: &[String]) -> String {
        let mut sorted_mods = mods.to_vec();
        sorted_mods.sort();
        
        // Create a simple hash by joining all mod names
        let combined = sorted_mods.join("_");
        format!("{:x}", md5::compute(combined))
    }
    
    // Check if we have a valid cached overlay for the given mods
    pub fn get_cached_overlay(&mut self, mods: &[String]) -> Option<PathBuf> {
        // Clean up old entries first if needed
        self.cleanup_old_entries();
        
        let hash = self.generate_hash(mods);
        
        // Check if we have a cached overlay
        if let Some((path, time)) = self.overlays.get_mut(&hash) {
            // Check if the overlay exists and is not too old (30 minutes max)
            if path.exists() && time.elapsed() < Duration::from_secs(30 * 60) {
                // Update the timestamp to keep this entry fresh
                *time = Instant::now();
                return Some(path.clone());
            }
        }
        
        None
    }
    
    // Add a newly built overlay to the cache
    pub fn add_overlay(&mut self, mods: &[String], path: PathBuf) {
        let hash = self.generate_hash(mods);
        self.overlays.insert(hash, (path, Instant::now()));
        
        // Maybe clean up old entries if we haven't in a while
        self.cleanup_old_entries();
    }
    
    // Clean up old cache entries
    fn cleanup_old_entries(&mut self) {
        // Only clean up once per hour
        if let Some(last_time) = self.last_cleanup {
            if last_time.elapsed() < Duration::from_secs(3600) {
                return;
            }
        }
        
        // Remove entries older than 2 hours
        let max_age = Duration::from_secs(2 * 3600);
        let now = Instant::now();
        
        self.overlays.retain(|_, (path, time)| {
            let keep = time.elapsed() < max_age && path.exists();
            // Try to remove the directory if we're discarding it
            if !keep && path.exists() {
                let _ = std::fs::remove_dir_all(path);
            }
            keep
        });
        
        self.last_cleanup = Some(now);
    }
}

// Error handling similar to CS LOL Manager
#[derive(Debug)]
pub enum InjectionError {
    IoError(io::Error),
    InvalidGamePath(String),
    MissingFantomeFile(String),
    ProcessError(String),
    ConfigError(String),
    OverlayError(String),
    Timeout(String),
    Aborted(String),
    WalkdirError(walkdir::Error),
    ZipError(zip::result::ZipError),
}

impl std::fmt::Display for InjectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::IoError(err) => write!(f, "IO Error: {}", err),
            Self::InvalidGamePath(msg) => write!(f, "Invalid game path: {}", msg),
            Self::MissingFantomeFile(msg) => write!(f, "Missing fantome file: {}", msg),
            Self::ProcessError(msg) => write!(f, "Process error: {}", msg),
            Self::ConfigError(msg) => write!(f, "Configuration error: {}", msg),
            Self::OverlayError(msg) => write!(f, "Overlay error: {}", msg),
            Self::Timeout(msg) => write!(f, "Timeout: {}", msg),
            Self::Aborted(msg) => write!(f, "Aborted: {}", msg),
            Self::WalkdirError(err) => write!(f, "Walkdir error: {}", err),
            Self::ZipError(err) => write!(f, "Zip error: {}", err),
        }
    }
}

impl std::error::Error for InjectionError {}

impl From<io::Error> for InjectionError {
    fn from(err: io::Error) -> Self {
        Self::IoError(err)
    }
}

impl From<walkdir::Error> for InjectionError {
    fn from(err: walkdir::Error) -> Self {
        Self::WalkdirError(err)
    }
}

impl From<zip::result::ZipError> for InjectionError {
    fn from(err: zip::result::ZipError) -> Self {
        Self::ZipError(err)
    }
}

// Define the types we need
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Skin {
    pub champion_id: u32,
    pub skin_id: u32,
    pub chroma_id: Option<u32>,
    pub fantome_path: Option<String>, // Add fantome path from the JSON
}

// ModState enum - Similar to CS LOL Manager's state machine
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ModState {
    Uninitialized,
    Idle,
    Busy,
    Running,
    CriticalError,
}

// This represents a message event for the patcher
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PatcherMessage {
    WaitStart,
    Found,
    WaitInit,
    Scan,
    NeedSave,
    WaitPatchable,
    Patch,
    WaitExit,
    Done,
}

impl PatcherMessage {
    pub fn to_string(&self) -> &'static str {
        match self {
            Self::WaitStart => "Waiting for league match to start",
            Self::Found => "Found League",
            Self::WaitInit => "Wait initialized",
            Self::Scan => "Scanning",
            Self::NeedSave => "Saving",
            Self::WaitPatchable => "Wait patchable",
            Self::Patch => "Patching",
            Self::WaitExit => "Waiting for exit",
            Self::Done => "League exited",
        }
    }
}

// Main skin injector class - simplified without profiles
pub struct SkinInjector {
    state: ModState,
    app_dir: PathBuf,
    root_path: PathBuf,  // Store the root League directory path
    game_path: PathBuf,  // Store the Game subdirectory path
    status: String,
    log_file: Option<File>,
    mod_tools_path: Option<PathBuf>, // Add mod_tools path
    champion_names: std::collections::HashMap<u32, String>, // Add cache for champion names
    app_handle: Option<AppHandle>,
}


// Add a FileIndex struct to cache paths and champion data
#[derive(Debug, Default)]
pub struct FileIndex {
    // Map champion_id to champion name
    champion_names: HashMap<u32, String>,
    // Map (champion_id, skin_id) to fantome file path
    skin_paths: HashMap<(u32, Option<u32>), Vec<PathBuf>>,
    // Map champion name to champion ID
    champion_ids: HashMap<String, u32>,
    // Track all discovered fantome files
    all_fantome_files: Vec<(PathBuf, Instant)>,
    // Track fantome files by filename for quick lookup
    fantome_by_filename: HashMap<String, PathBuf>,
    // Last time the index was built
    last_indexed: Option<Instant>,
}

impl FileIndex {
    // Create a new empty index
    pub fn new() -> Self {
        Self::default()
    }
    
    // Index all champions in a directory
    pub fn index_champions(&mut self, champions_dir: &Path) -> Result<(), InjectionError> {
        println!("Indexing champions in {}", champions_dir.display());
        let start = Instant::now();
        
        if !champions_dir.exists() {
            return Ok(());
        }
        
        let entries = fs::read_dir(champions_dir)?;
        
        for entry in entries.filter_map(Result::ok) {
            let path = entry.path();
            if !path.is_dir() {
                continue;
            }
            
            let champion_name = path.file_name()
                .and_then(|n| n.to_str())
                .map(|s| s.to_lowercase())
                .unwrap_or_default();
                
            // Look for champion JSON file
            let json_file = path.join(format!("{}.json", champion_name));
            
            if let Ok(content) = fs::read_to_string(&json_file) {
                if let Ok(data) = serde_json::from_str::<serde_json::Value>(&content) {
                    if let Some(id) = data.get("id").and_then(|v| v.as_u64()) {
                        let champion_id = id as u32;
                        self.champion_names.insert(champion_id, champion_name.clone());
                        self.champion_ids.insert(champion_name, champion_id);
                    }
                }
            }
        }
        
        println!("Indexed {} champions in {:?}", self.champion_names.len(), start.elapsed());
        Ok(())
    }
    
    // Index all fantome files in a directory structure
    pub fn index_fantome_files(&mut self, base_dir: &Path) -> Result<(), InjectionError> {
        println!("Indexing fantome files in {}", base_dir.display());
        let start = Instant::now();
        
        // Clear existing data
        self.skin_paths.clear();
        self.fantome_by_filename.clear();
        self.all_fantome_files.clear();
        
        if !base_dir.exists() {
            return Ok(());
        }
        
        // Walk the directory tree
        for entry in WalkDir::new(base_dir) {
            let entry = entry?;
            let path = entry.path();
            
            if !path.is_file() || path.extension().and_then(|ext| ext.to_str()) != Some("fantome") {
                continue;
            }
            
            let filename = path.file_name()
                .and_then(|n| n.to_str())
                .unwrap_or_default()
                .to_string();
                
            // Store by filename for direct lookups
            self.fantome_by_filename.insert(filename.clone(), path.to_path_buf());
            
            // Store in all files collection
            self.all_fantome_files.push((path.to_path_buf(), Instant::now()));
            
            // Try to parse the filename for champion/skin IDs
            // Format examples: ChampionName_SkinID.fantome or ChampionName_SkinID_chroma_ChromaID.fantome
            let parts: Vec<&str> = filename.split('_').collect();
            
            if parts.len() >= 2 {
                // The part before the first underscore might be the champion name
                let possible_champion_name = parts[0].to_lowercase();
                
                // Try to find champion ID from name
                if let Some(&champion_id) = self.champion_ids.get(&possible_champion_name) {
                    // The second part might be the skin ID
                    if let Some(skin_id_str) = parts.get(1) {
                        if let Ok(skin_id) = skin_id_str.parse::<u32>() {
                            // Check if it's a chroma
                            let chroma_id = if parts.len() >= 4 && parts[2] == "chroma" {
                                parts.get(3).and_then(|id_str| id_str.parse::<u32>().ok())
                            } else {
                                None
                            };
                            
                            // Store the path indexed by (champion_id, skin_id, chroma_id)
                            let key = (champion_id, chroma_id);
                            self.skin_paths.entry(key)
                                .or_insert_with(Vec::new)
                                .push(path.to_path_buf());
                        }
                    }
                }
            }
        }
        
        self.last_indexed = Some(Instant::now());
        println!("Indexed {} fantome files in {:?}", 
            self.all_fantome_files.len(), start.elapsed());
        
        Ok(())
    }
    
    // Find fantome file for a skin using the indexed data
    pub fn find_fantome_for_skin(&self, skin: &Skin, fantome_files_dir: &Path) -> Option<PathBuf> {
        // First, check if we have it in our skin paths table
        let key = (skin.champion_id, skin.chroma_id);
        
        if let Some(paths) = self.skin_paths.get(&key) {
            for path in paths {
                // For indexed paths, verify they exist and contain the skin ID
                if path.exists() {
                    let filename = path.file_name()
                        .and_then(|n| n.to_str())
                        .unwrap_or_default();
                    
                    if filename.contains(&skin.skin_id.to_string()) {
                        return Some(path.clone());
                    }
                }
            }
        }
        
        // If not found, check direct path from JSON if provided
        if let Some(fantome_path) = &skin.fantome_path {
            // Try direct file lookup first (fastest)
            let filename = fantome_path.split('/').last().unwrap_or(fantome_path);
            if let Some(path) = self.fantome_by_filename.get(filename) {
                if path.exists() {
                    return Some(path.clone());
                }
            }
            
            // Try direct path
            let direct_path = fantome_files_dir.join(fantome_path);
            if direct_path.exists() {
                return Some(direct_path);
            }
        }
        
        // Not found in index
        None
    }
    
    // Get champion name, preferring the cached version
    pub fn get_champion_name(&self, champion_id: u32) -> Option<String> {
        self.champion_names.get(&champion_id).cloned()
    }
    
    // Check if index needs refresh (older than 5 minutes)
    pub fn needs_refresh(&self) -> bool {
        match self.last_indexed {
            Some(time) => time.elapsed().as_secs() > 300, // 5 minutes
            None => true,
        }
    }
}

// Create a global static instance for caching across the application
pub static GLOBAL_FILE_INDEX: Lazy<Arc<Mutex<FileIndex>>> = Lazy::new(|| {
    Arc::new(Mutex::new(FileIndex::new()))
});

// Function to get or initialize the global index
pub fn get_global_index(app_handle: &AppHandle) -> Result<Arc<Mutex<FileIndex>>, InjectionError> {
    let index = GLOBAL_FILE_INDEX.clone();
    
    // Check if we need to initialize the index
    let needs_init = {
        let locked_index = index.lock().unwrap();
        locked_index.champion_names.is_empty() || locked_index.needs_refresh()
    };
    
    if needs_init {
        // Get the champions directory path
        let app_data_dir = app_handle.path().app_data_dir()
            .map_err(|e| InjectionError::IoError(io::Error::new(io::ErrorKind::NotFound, format!("{}", e))))?;
        let champions_dir = app_data_dir.join("champions");
        
        // Initialize with locked access
        let mut locked_index = index.lock().unwrap();
        locked_index.index_champions(&champions_dir)?;
        locked_index.index_fantome_files(&champions_dir)?;
    }
    
    Ok(index)
}

// Add a function to check for and copy the pre-built default overlay
fn copy_default_overlay(app_handle: &AppHandle, destination: &Path) -> Result<bool, InjectionError> {
    // Check if we have a pre-built overlay in resources
    if let Ok(resource_dir) = app_handle.path().resource_dir() {
        // First check in cslol-tools subfolder
        let default_overlay = resource_dir.join("cslol-tools").join("empty_overlay");
        if default_overlay.exists() && default_overlay.is_dir() {
            println!("Found pre-built overlay at: {}", default_overlay.display());
            
            // Create the destination directory if it doesn't exist
            if !destination.exists() {
                fs::create_dir_all(destination)?;
            }
            
            // Copy the files from the default overlay
            for entry in WalkDir::new(&default_overlay) {
                let entry = entry?;
                let path = entry.path();
                let rel_path = path.strip_prefix(&default_overlay)
                    .map_err(|e| InjectionError::ProcessError(format!("Path error: {}", e)))?;
                
                let target_path = destination.join(rel_path);
                
                if path.is_dir() {
                    fs::create_dir_all(&target_path)?;
                } else if path.is_file() {
                    if let Some(parent) = target_path.parent() {
                        if !parent.exists() {
                            fs::create_dir_all(parent)?;
                        }
                    }
                    fs::copy(path, &target_path)?;
                }
            }
            
            println!("Successfully copied pre-built overlay template");
            return Ok(true);
        }
    }
    
    Ok(false)
}

fn emit_terminal_log_injection(app: &AppHandle, message: &str) {
    let log = TerminalLog {
        message: message.to_string(),
        log_type: "injection".to_string(),
        timestamp: Utc::now().to_rfc3339(),
    };
    let _ = app.emit("terminal-log", log);
}