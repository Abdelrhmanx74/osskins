name: Build & Publish Updater Artifacts (Windows only)

on:
  push:
    tags:
      - 'v*'

jobs:
  create_release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      release_id: ${{ steps.create_release.outputs.id }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          release_name: Release ${{ github.ref_name }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build_and_upload:
    name: Build on Windows and upload
    needs: create_release
    runs-on: windows-latest
    env:
      RELEASE_TAG: ${{ github.ref_name }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          pnpm-version: 8

      - name: Install dependencies
        shell: pwsh
        run: pnpm install

      - name: Build frontend
        shell: pwsh
        run: pnpm build

      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Build tauri bundle
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        shell: pwsh
        run: pnpm tauri build

      - name: Find all Windows bundle files (exe/msi and .sig)
        id: find_all
        shell: pwsh
        run: |
          $root = "src-tauri\target\release\bundle"
          Write-Host "Searching under $root"
          $files = Get-ChildItem -Path $root -Recurse -File -ErrorAction SilentlyContinue |
            Where-Object { $_.Extension -in ".exe", ".msi", ".sig" }
          if (-not $files) { Write-Error "No artifacts found"; exit 1 }
          $list = $files | ForEach-Object { $_.FullName }
          $joined = ($list -join "`n")
          Write-Host "Artifacts:`n$joined"
          # Save newline-separated list to GITHUB_OUTPUT
          $joined | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          Add-Content -Path $env:GITHUB_OUTPUT -Value "files<<EOF`n$joined`nEOF"

      - name: Upload all artifacts to release (exe/msi/sig)
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if (-not (Get-Command gh -ErrorAction SilentlyContinue)) {
            choco install gh -y | Out-Null
          }
          $files = "${{ steps.find_all.outputs.files }}".Split("`n") | Where-Object { $_ -ne "" }
          foreach ($f in $files) {
            Write-Host "Uploading $f"
            gh release upload "$env:RELEASE_TAG" "$f" --clobber
          }

      - name: Compute sha256 and create metadata file (Windows)
        id: meta
        shell: pwsh
        run: |
          # Optional: keep if you still want a side meta json
          $root = "src-tauri\target\release\bundle"
          $exe = Get-ChildItem -Path $root -Recurse -File | Where-Object { $_.Name -like "*.exe" } | Select-Object -First 1
          if ($null -eq $exe) { Write-Error "No .exe found"; exit 1 }
          $hash = Get-FileHash -Algorithm SHA256 -Path $exe.FullName
          $obj = @{
            platform = "windows"
            file = $exe.Name
            sha256 = $hash.Hash.ToLower()
            size = [int64](Get-Item $exe.FullName).Length
          }
          $metafile = "meta-windows.json"
          $obj | ConvertTo-Json -Depth 4 | Out-File -FilePath $metafile -Encoding utf8
          Add-Content -Path $env:GITHUB_OUTPUT -Value "meta_file=$metafile"

      - name: Upload metadata file to release
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create_release.outputs.upload_url }}
          asset_path: ${{ steps.meta.outputs.meta_file }}
          asset_name: ${{ steps.meta.outputs.meta_file }}
          asset_content_type: application/json

  generate_metadata:
    name: Generate updates.json from Tauri .sig
    needs: [create_release, build_and_upload]
    runs-on: ubuntu-latest
    steps:
      - name: Install jq, curl
        run: |
          sudo apt-get update && sudo apt-get install -y jq curl

      - name: Build updates.json using uploaded assets and Tauri signatures
        env:
          REPO: ${{ github.repository }}
          RELEASE_ID: ${{ needs.create_release.outputs.release_id }}
          TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSION: ${{ github.ref_name }}
        run: |
          API="https://api.github.com/repos/$REPO/releases/$RELEASE_ID/assets"
          echo "Listing assets from $API"
          curl -s -H "Authorization: token $TOKEN" "$API" > /tmp/assets.json
          cat /tmp/assets.json | jq -r '.[].name' | sed 's/^/ - /'

          # Pick NSIS .exe for updates; pair with its .sig
          exe_url=$(jq -r '.[] | select(.name|endswith(".exe")) | .browser_download_url' /tmp/assets.json | head -n1)
          sig_url=$(jq -r '.[] | select(.name|endswith(".exe.sig")) | .browser_download_url' /tmp/assets.json | head -n1)

          if [ -z "$exe_url" ]; then echo "No .exe found in assets"; exit 1; fi
          if [ -z "$sig_url" ]; then echo "No .exe.sig found in assets"; exit 1; fi

          curl -sL -H "Authorization: token $TOKEN" -o /tmp/app.exe "$exe_url"
          curl -sL -H "Authorization: token $TOKEN" -o /tmp/app.exe.sig "$sig_url"

          # Tauri .sig contains the updater signature; trim whitespace/newlines
          signature=$(tr -d '\r\n' < /tmp/app.exe.sig)

          now=$(date --utc +"%Y-%m-%dT%H:%M:%SZ")

          jq -n --arg v "$VERSION" --arg d "$now" --arg u "$exe_url" --arg s "$signature" \
            '{
              version:$v,
              pub_date:$d,
              platforms:{
                windows: {
                  url:$u,
                  signature:$s
                }
              }
            }' > updates.json

          cat updates.json

      - name: Upload updates.json to release
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create_release.outputs.upload_url }}
          asset_path: updates.json
          asset_name: updates.json
          asset_content_type: application/json
