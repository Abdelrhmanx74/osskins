name: Build & Publish Updater Artifacts (Windows only)

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  create_release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      release_id: ${{ steps.create_release.outputs.id }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          release_name: Release ${{ github.ref_name }}
          draft: false
          prerelease: ${{ contains(github.ref_name, '-test') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build_and_upload:
    name: Build on Windows and upload
    needs: create_release
    runs-on: windows-latest
    env:
      IS_TEST: ${{ contains(github.ref_name, '-test') }}
      UPLOAD_URL_TEMPLATE: ${{ needs.create_release.outputs.upload_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          pnpm-version: 8

      - name: Install dependencies
        shell: pwsh
        run: |
          pnpm install

      - name: Build frontend
        shell: pwsh
        run: |
          pnpm build

      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Build tauri bundle
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        shell: pwsh
        run: |
          pnpm tauri build

      - name: Find and upload bundle artifacts (Windows)
        id: upload_artifacts
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          IS_TEST: ${{ env.IS_TEST }}
          UPLOAD_URL_TEMPLATE: ${{ env.UPLOAD_URL_TEMPLATE }}
        run: |
          Write-Host "Searching for bundle artifacts under src-tauri\target\release\bundle and target"
          $patterns = @('*.msi','*.exe','*.zip','*.dmg','*.AppImage','*.deb','*.tar.gz')
          $searchRoots = @("src-tauri\target\release\bundle", "target")
          $found = @()

          foreach ($root in $searchRoots) {
            foreach ($p in $patterns) {
              try {
                $found += Get-ChildItem -Path $root -Recurse -File -Include $p -ErrorAction SilentlyContinue
              } catch {
                # ignore missing directories
              }
            }
          }

          $found = $found | Sort-Object FullName -Unique

          if (-not $found -or $found.Count -eq 0) {
            Write-Error "No build artifacts found"
            exit 1
          }

          Write-Host "Found artifacts:"
          $found | ForEach-Object { Write-Host "- $($_.FullName)" }

          # upload_url is a template like https://uploads.github.com/.../assets{?name,label}
          $upload_template = $env:UPLOAD_URL_TEMPLATE
          if (-not $upload_template) {
            Write-Error "Missing upload_url from release creation"
            exit 1
          }
          $upload_base = $upload_template -replace '\{.*\}',''

          foreach ($f in $found) {
            $nameEscaped = [System.Uri]::EscapeDataString($f.Name)
            $upload_url = "$upload_base?name=$nameEscaped"
            Write-Host "Uploading asset $($f.Name) to $upload_url"
            $resp = & curl -sS -X POST -H "Authorization: token $($env:GITHUB_TOKEN)" -H "Content-Type: application/octet-stream" --data-binary "@$($f.FullName)" $upload_url
            if ($LASTEXITCODE -ne 0) {
              Write-Error "Upload failed for $($f.FullName)"
              exit 1
            } else {
              Write-Host "Uploaded $($f.Name)"
            }

            # Check for sidecar .sig files adjacent to artifact
            $sigPath1 = "$($f.FullName).sig"
            $sigPath2 = Join-Path $f.DirectoryName ("$($f.BaseName).sig")
            $sigToUpload = $null
            if (Test-Path $sigPath1) { $sigToUpload = $sigPath1 }
            elseif (Test-Path $sigPath2) { $sigToUpload = $sigPath2 }

            if ($sigToUpload) {
              $sigNameEscaped = [System.Uri]::EscapeDataString((Split-Path $sigToUpload -Leaf))
              $sigUploadUrl = "$upload_base?name=$sigNameEscaped"
              Write-Host "Uploading signature $sigToUpload to $sigUploadUrl"
              & curl -sS -X POST -H "Authorization: token $($env:GITHUB_TOKEN)" -H "Content-Type: application/octet-stream" --data-binary "@$sigToUpload" $sigUploadUrl
              if ($LASTEXITCODE -ne 0) {
                Write-Warning "Failed to upload signature $sigToUpload (non-fatal)"
              } else {
                Write-Host "Uploaded signature $(Split-Path $sigToUpload -Leaf)"
              }
            } else {
              if ($env:IS_TEST -eq 'True' -or $env:IS_TEST -eq 'true') {
                Write-Host "No .sig found for $($f.Name) â€” running in test mode, continuing."
              } else {
                Write-Error "No .sig found for $($f.Name) and this is not a -test release. Aborting."
                exit 1
              }
            }
          }

  generate_metadata:
    name: Generate updates.json and sign assets
    needs: build_and_upload
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install jq, openssl, curl
        run: |
          sudo apt-get update && sudo apt-get install -y jq openssl curl

      - name: Prepare private key
        env:
          UPDATER_PRIVATE_KEY: ${{ secrets.UPDATER_PRIVATE_KEY }}
        run: |
          if [ -z "$UPDATER_PRIVATE_KEY" ]; then echo "Missing UPDATER_PRIVATE_KEY secret"; exit 1; fi
          echo "$UPDATER_PRIVATE_KEY" > private.pem
          chmod 600 private.pem

      - name: List release assets
        env:
          REPO: ${{ github.repository }}
          RELEASE_ID: ${{ needs.create_release.outputs.release_id }}
          TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          API="https://api.github.com/repos/$REPO/releases/$RELEASE_ID/assets"
          echo "Listing assets from $API"
          curl -s -H "Authorization: token $TOKEN" "$API" > /tmp/assets.json
          cat /tmp/assets.json | jq -r '.[] | .name' > /tmp/asset-names.txt
          echo "Assets:"; cat /tmp/asset-names.txt

      - name: Download assets and compute hashes/signatures
        env:
          REPO: ${{ github.repository }}
          RELEASE_ID: ${{ needs.create_release.outputs.release_id }}
          TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          mkdir -p /tmp/assetfiles
          jq -c '.[]' /tmp/assets.json | while read -r a; do
            name=$(echo "$a" | jq -r .name)
            url=$(echo "$a" | jq -r .browser_download_url)
            echo "Downloading $name from $url"
            curl -sL -H "Authorization: token $TOKEN" -o "/tmp/assetfiles/$name" "$url"
            sha256=$(sha256sum "/tmp/assetfiles/$name" | awk '{print $1}')
            size=$(stat -c%s "/tmp/assetfiles/$name" 2>/dev/null || stat -f%z "/tmp/assetfiles/$name")
            sig=$(openssl dgst -sha256 -sign private.pem "/tmp/assetfiles/$name" | openssl base64 -A)
            platform="unknown"
            case "$name" in
              *.exe*|*.msi*) platform="windows" ;;
              *.dmg*) platform="macos" ;;
              *.AppImage*|*.deb*|*.tar.gz*) platform="linux" ;;
            esac
            entry=$(jq -n --arg p "$platform" --arg n "$name" --arg u "$url" --arg h "$sha256" --arg s "$sig" --arg sz "$size" '{platform:$p, file:$n, url:$u, sha256:$h, signature:$s, size:(($sz|tonumber))}')
            echo "$entry" >> /tmp/entries.ndjson
          done

      - name: Build updates.json
        env:
          VERSION: ${{ github.ref_name }}
        run: |
          now=$(date --utc +"%Y-%m-%dT%H:%M:%SZ")
          jq -s 'reduce .[] as $item ({}; .[$item.platform]=$item)' /tmp/entries.ndjson > /tmp/platforms.json
          jq -n --arg v "$VERSION" --arg d "$now" --slurpfile P /tmp/platforms.json '{version:$v, pub_date:$d, platforms: ($P[0])}' > updates.json
          sig=$(openssl dgst -sha256 -sign private.pem updates.json | openssl base64 -A)
          jq --arg s "$sig" '. + {signature:$s}' updates.json > updates.signed.json
          mv updates.signed.json updates.json

      - name: Upload updates.json to release
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create_release.outputs.upload_url }}
          asset_path: updates.json
          asset_name: updates.json
          asset_content_type: application/json
