name: Build & Publish Tauri Windows Release

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write

jobs:
  build_and_release:
    name: Build on Windows and create Release via tauri-action
    runs-on: windows-latest
    env:
      TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
      TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout repository (with submodules)
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: "8"

      - name: Install frontend deps
        shell: pwsh
        run: pnpm install

      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Run tauri-action (build & release)
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          tagName: ${{ github.ref_name }}
          releaseName: "Osskins ${{ github.ref_name }}"
          releaseBody: "Release built by CI (tauri-action)."
          releaseDraft: false
          prerelease: false
          args: ""

      - name: Upload installers to release (skip if release already has installers)
        shell: pwsh
        env:
          RELEASE_TAG: ${{ github.ref_name }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if (-not (Get-Command gh -ErrorAction SilentlyContinue)) {
            choco install gh -y | Out-Null
          }

          # Authenticate gh with the token (non-interactive)
          echo $env:GITHUB_TOKEN | gh auth login --with-token

          Write-Host "Checking existing assets on release $RELEASE_TAG"
          $assetNames = $null
          try {
            $assetNames = gh release view $RELEASE_TAG --json assets -q '.assets[].name' 2>$null
          } catch {
            $out = gh release view $RELEASE_TAG 2>$null
            $assetNames = ($out -split "`n") | ForEach-Object {
              if ($_ -match '^asset:\s*(.+)$') { $matches[1] }
            } | Where-Object { $_ -ne $null }
          }

          if ($assetNames -and $assetNames.Count -gt 0) {
            Write-Host "Release already contains assets. Assets found:"
            $assetNames | ForEach-Object { Write-Host " - $_" }
            Write-Host "Skipping installer upload step."
            exit 0
          }

          # No existing assets — upload installers if present
          $bundle = "src-tauri\target\release\bundle"
          Write-Host "Searching for installers under $bundle"
          $paths = Get-ChildItem -Path $bundle -Recurse -File -ErrorAction SilentlyContinue |
            Where-Object { $_.Extension -in ".exe", ".msi", ".AppImage", ".dmg", ".zip", ".tar.gz" }

          if (-not $paths) {
            Write-Host "No installers found to upload. Listing bundle tree (if present):"
            if (Test-Path $bundle) {
              Get-ChildItem -Path $bundle -Recurse | ForEach-Object { Write-Host $_.FullName }
            } else {
              Write-Host "Bundle path $bundle does not exist."
            }
            Write-Host "Nothing to upload; continuing."
            exit 0
          }

          foreach ($p in $paths) {
            $full = $p.FullName
            Write-Host "Attempting upload of $full to release $RELEASE_TAG"
            $args = @($RELEASE_TAG, $full, '--clobber')
            & gh release upload @args
            if ($LASTEXITCODE -ne 0) {
              Write-Host "WARNING: gh release upload returned exit code $LASTEXITCODE for $full — continuing."
            } else {
              Write-Host "Upload succeeded for $full"
            }
          }

          Write-Host "Upload step finished (uploads attempted where needed)."

  generate_updates_json:
    name: Generate static updates.json from uploaded release assets
    runs-on: ubuntu-latest
    needs: build_and_release
    env:
      REPO: ${{ github.repository }}
      TOKEN: ${{ secrets.GITHUB_TOKEN }}
      VERSION: ${{ github.ref_name }}
    steps:
      - name: Install jq & curl
        run: sudo apt-get update && sudo apt-get install -y jq curl

      - name: Lookup release by tag
        run: |
          TAG=${GITHUB_REF##*/}
          echo "Looking up release for tag $TAG"
          API="https://api.github.com/repos/${REPO}/releases/tags/${TAG}"
          curl -s -H "Authorization: token ${TOKEN}" "$API" > /tmp/release.json
          if [ ! -s /tmp/release.json ]; then
            echo "/tmp/release.json is empty; release lookup failed" >&2
            jq -C . /tmp/release.json || true
            exit 1
          fi
          echo "Release found:"
          jq -r '.name, .id, .tag_name' /tmp/release.json || true
          jq -r '.assets[].name' /tmp/release.json || true

      - name: Build updates.json using uploaded assets and Tauri signatures
        run: |
          # Use the release JSON produced above
          assets_json=/tmp/release.json
          echo "Assets present:"
          jq -r '.assets[].name' $assets_json || true

          # Prefer an installer by common extensions (.exe, .msi, .AppImage, .tar.gz, .zip, .dmg)
          installer_url=$(jq -r '.assets[] | select(.name|test("\\.(exe|msi|AppImage|tar.gz|zip|dmg)$")) | .browser_download_url' $assets_json | head -n1)

          # If no installer found, try to match a .sig to a base name (e.g. foo.exe.sig -> foo.exe)
          if [ -z "$installer_url" ]; then
            sig_name=$(jq -r '.assets[] | select(.name|endswith(".sig")) | .name' $assets_json | head -n1)
            if [ -n "$sig_name" ]; then
              base_name="${sig_name%.sig}"
              echo "Found signature $sig_name; trying base $base_name"
              installer_url=$(jq -r --arg b "$base_name" '.assets[] | select(.name==$b) | .browser_download_url' $assets_json | head -n1)
            fi
          fi

          if [ -z "$installer_url" ]; then
            echo "No installer asset found in release. Available assets:"
            jq -r '.assets[].name' $assets_json || true
            echo ""
            echo "Make sure the Windows build job uploaded the installer (.exe or .msi) to the release. The job may have uploaded only the .sig."
            exit 1
          fi

          # Determine installer name and matching sig
          installer_name=$(basename "$installer_url")
          sig_asset_name="${installer_name}.sig"
          sig_url=$(jq -r --arg n "$sig_asset_name" '.assets[] | select(.name==$n) | .browser_download_url' $assets_json | head -n1)

          # Fallback: use first .sig if exact match not found
          if [ -z "$sig_url" ]; then
            sig_url=$(jq -r '.assets[] | select(.name|endswith(".sig")) | .browser_download_url' $assets_json | head -n1)
            if [ -n "$sig_url" ]; then
              echo "Warning: exact matching .sig not found. Falling back to first .sig in release."
            fi
          fi

          if [ -z "$sig_url" ]; then
            echo "No .sig asset found in release. Available assets:"
            jq -r '.assets[].name' $assets_json || true
            exit 1
          fi

          echo "Using installer: $installer_name"
          echo "Installer URL: $installer_url"
          echo "Signature URL: $sig_url"

          # Download the .sig and trim newlines (Tauri expects raw signature content)
          curl -sL -H "Authorization: token $TOKEN" -o /tmp/installer.sig "$sig_url"
          if [ ! -s /tmp/installer.sig ]; then
            echo "Downloaded .sig is empty" >&2
            exit 1
          fi
          signature=$(tr -d '\r\n' < /tmp/installer.sig)

          # Use version without leading v
          ver="${VERSION#v}"
          now=$(date --utc +"%Y-%m-%dT%H:%M:%SZ")

          jq -n --arg v "$ver" --arg d "$now" --arg u "$installer_url" --arg s "$signature" \
            '{
              version:$v,
              pub_date:$d,
              platforms:{
                "windows-x86_64": {
                  url:$u,
                  signature:$s
                }
              }
            }' > updates.json

          echo "Built updates.json:"
          cat updates.json

      - name: Upload updates.json to release via GitHub uploads API
        env:
          TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get upload_url from the release JSON and strip template suffix
          upload_url_template=$(jq -r .upload_url /tmp/release.json)
          upload_url="${upload_url_template%\{*}"
          echo "Uploading updates.json to $upload_url?name=updates.json"
          response=$(curl -sSL -X POST -H "Authorization: token $TOKEN" \
            -H "Content-Type: application/json" --data-binary @updates.json \
            "$upload_url?name=updates.json")
          echo "Upload response summary:"
          echo "$response" | jq -r '.url, .state, .browser_download_url' || echo "$response"
