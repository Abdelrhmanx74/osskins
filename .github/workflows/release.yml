name: Build & Publish Tauri Windows Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  build_and_release:
    name: Build on Windows and create Release via tauri-action
    runs-on: windows-latest
    env:
      TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
      TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout repository (with submodules)
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          pnpm-version: 8

      - name: Install frontend deps
        shell: pwsh
        run: pnpm install

      - name: Build frontend
        shell: pwsh
        run: pnpm build

      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Run tauri-action (build & release)
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          # If you already tag the repo to trigger this workflow, use the tag.
          # tauri-action can substitute __VERSION__ by reading tauri.conf.json; if you prefer that behavior use tagName: app-v__VERSION__
          tagName: ${{ github.ref_name }}
          releaseName: 'Osskins ${{ github.ref_name }}'
          releaseBody: 'Release built by CI (tauri-action).'
          releaseDraft: false
          prerelease: false
          args: ''

  generate_updates_json:
    name: Generate static updates.json from uploaded release assets
    runs-on: ubuntu-latest
    needs: build_and_release
    env:
      REPO: ${{ github.repository }}
      RELEASE_ID: ${{ needs.build_and_release.outputs.release_id }}
      TOKEN: ${{ secrets.GITHUB_TOKEN }}
      VERSION: ${{ github.ref_name }}
    steps:
      - name: Install jq & curl
        run: sudo apt-get update && sudo apt-get install -y jq curl

      - name: List release assets
        run: |
          # We need the release ID created by tauri-action; tauri-action normally creates the release and outputs info in logs.
          # If tauri-action did not expose the release id, we lookup the release by tag:
          TAG=${GITHUB_REF##*/} # e.g. v1.2.3
          echo "Looking up release for tag $TAG"
          API="https://api.github.com/repos/${REPO}/releases/tags/$TAG"
          curl -s -H "Authorization: token ${TOKEN}" "$API" > /tmp/release.json
          jq -r '.assets[].name' /tmp/release.json || true
          cat /tmp/release.json > /tmp/assets.json

      - name: Choose installer asset + matching .sig
        id: pick
        run: |
          # Prefer NSIS .exe, fallback to MSI
          exe_name=$(jq -r '.assets[] | select(.name|endswith(".exe")) | .name' /tmp/assets.json | head -n1)
          msi_name=$(jq -r '.assets[] | select(.name|endswith(".msi")) | .name' /tmp/assets.json | head -n1)
          if [ -n "$exe_name" ]; then
            installer="$exe_name"
            sig_name="${exe_name}.sig"
          elif [ -n "$msi_name" ]; then
            installer="$msi_name"
            sig_name="${msi_name}.sig"
          else
            echo "No installer (.exe or .msi) found in release assets" >&2
            exit 1
          fi
          echo "installer=$installer" >> $GITHUB_OUTPUT
          echo "sig_name=$sig_name" >> $GITHUB_OUTPUT

      - name: Fetch asset URLs and signature content
        env:
          TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          installer="${{ steps.pick.outputs.installer }}"
          sig_name="${{ steps.pick.outputs.sig_name }}"
          echo "Selected installer: $installer"
          API_ASSETS="https://api.github.com/repos/${REPO}/releases/tags/${GITHUB_REF##*/}"
          # get download urls
          installer_url=$(jq -r --arg n "$installer" '.assets[] | select(.name==$n) | .browser_download_url' /tmp/assets.json)
          sig_url=$(jq -r --arg n "$sig_name" '.assets[] | select(.name==$n) | .browser_download_url' /tmp/assets.json)

          if [ -z "$installer_url" ] || [ -z "$sig_url" ]; then
            echo "Installer or its .sig not found among release assets" >&2
            jq -r '.assets[].name' /tmp/assets.json >&2 || true
            exit 1
          fi

          # Download the .sig and trim newlines (Tauri expects raw signature content)
          curl -sL -H "Authorization: token $TOKEN" -o /tmp/installer.sig "$sig_url"
          signature=$(tr -d '\r\n' < /tmp/installer.sig)

          # Use version without leading v
          ver="${VERSION#v}"
          now=$(date --utc +"%Y-%m-%dT%H:%M:%SZ")

          cat > updates.json <<EOF
{
  "version": "$ver",
  "pub_date": "$now",
  "platforms": {
    "windows-x86_64": {
      "url": "$installer_url",
      "signature": "$signature"
    }
  }
}
EOF

          echo "Built updates.json:"
          cat updates.json
      - name: Upload updates.json to release
        uses: actions/upload-release-asset@v1
        with:
          upload_url: $(jq -r .html_url /tmp/assets.json | sed 's#/tag/#/releases/tag/#' ) # fallback; will be ignored if not resolvable
          asset_path: updates.json
          asset_name: updates.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
