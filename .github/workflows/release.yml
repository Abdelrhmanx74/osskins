name: Release Build

on:
  push:
    tags:
      - "v*.*.*"
      - "v*.*-test"
      - "v*-test"
  workflow_dispatch:
    inputs:
      version:
        description: "Version to release (e.g., 1.5.2 or 1.5-test)"
        required: true
        type: string

env:
  TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
  TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}

jobs:
  release:
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: "windows-latest"
            args: ""
    
    runs-on: ${{ matrix.platform }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-pc-windows-msvc

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: "./src-tauri -> target"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build the app
        run: pnpm tauri build

      - name: Collect build artifacts (guarantee known location)
        id: collect
        shell: bash
        run: |
          echo "----------------------------------------"
          echo "ðŸ”Ž Collecting build artifacts into ./release-artifacts"
          # ensure globstar works and missing matches don't expand
          shopt -s globstar nullglob
          
          # Candidate searches (prefer the standard tauri bundle path first)
          SIG_CANDIDATES=(src-tauri/target/release/bundle/**/*.msi.sig src-tauri/target/release/**/*.msi.sig **/*.msi.sig)
          MSI_CANDIDATES=(src-tauri/target/release/bundle/**/*.msi src-tauri/target/release/**/*.msi **/*.msi)
          
          echo "DEBUG: SIG search patterns:"
          printf '  %s\n' "${SIG_CANDIDATES[@]}"
          echo "DEBUG: MSI search patterns:"
          printf '  %s\n' "${MSI_CANDIDATES[@]}"
          
          # Expand the patterns into real file lists (first non-empty set)
          SIG_FILES=()
          for p in "${SIG_CANDIDATES[@]}"; do
            files=( $p )
            if [ ${#files[@]} -gt 0 ]; then
              SIG_FILES=( "${files[@]}" )
              break
            fi
          done
          
          MSI_FILES=()
          for p in "${MSI_CANDIDATES[@]}"; do
            files=( $p )
            if [ ${#files[@]} -gt 0 ]; then
              MSI_FILES=( "${files[@]}" )
              break
            fi
          done
          
          echo "DEBUG: Found SIG files: ${SIG_FILES[*]:-<none>}"
          echo "DEBUG: Found MSI files: ${MSI_FILES[*]:-<none>}"
          
          mkdir -p release-artifacts
          
          # Copy any found signature(s) and installer(s) into release-artifacts
          copied=0
          for f in "${SIG_FILES[@]}"; do
            echo "Copying signature: $f -> release-artifacts/"
            cp -v "$f" release-artifacts/ || { echo "Failed to copy $f"; exit 1; }
            copied=$((copied+1))
          done
          for f in "${MSI_FILES[@]}"; do
            echo "Copying installer: $f -> release-artifacts/"
            cp -v "$f" release-artifacts/ || { echo "Failed to copy $f"; exit 1; }
            copied=$((copied+1))
          done
          
          # Fallback: if none found, also try top-level directory (some tools output there)
          if [ $copied -eq 0 ]; then
            echo "âš ï¸ No artifacts copied yet. Trying root and current dir fallback..."
            fallback_sig=(./*.msi.sig)
            fallback_msi=(./*.msi)
            echo "DEBUG: fallback_sig=${fallback_sig[*]}"
            echo "DEBUG: fallback_msi=${fallback_msi[*]}"
            for f in "${fallback_sig[@]}"; do
              if [ -f "$f" ]; then cp -v "$f" release-artifacts/ && copied=$((copied+1)); fi
            done
            for f in "${fallback_msi[@]}"; do
              if [ -f "$f" ]; then cp -v "$f" release-artifacts/ && copied=$((copied+1)); fi
            done
          fi
          
          echo "----------------------------------------"
          if [ $copied -eq 0 ]; then
            echo "âŒ CRITICAL: No .msi or .msi.sig found after all searches."
            echo "Workspace listing (top-level):"
            ls -la || true
            echo "src-tauri bundle listing (if present):"
            ls -la src-tauri/target/release/bundle || true
            exit 1
          fi
          
          echo "âœ… Files copied to release-artifacts:"
          ls -la release-artifacts || true
          
          # expose paths as outputs (first matches)
          FIRST_SIG=$(ls release-artifacts/*.msi.sig 2>/dev/null | head -n1 || true)
          FIRST_MSI=$(ls release-artifacts/*.msi 2>/dev/null | head -n1 || true)
          echo "sig=${FIRST_SIG:-}" >> $GITHUB_OUTPUT
          echo "msi=${FIRST_MSI:-}" >> $GITHUB_OUTPUT

      - name: Get version from tag or input
        id: version
        shell: bash
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "version=${{ inputs.version }}" >> $GITHUB_OUTPUT
            echo "tag=v${{ inputs.version }}" >> $GITHUB_OUTPUT
          else
            VERSION=${GITHUB_REF#refs/tags/v}
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "tag=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
          fi

      - name: Create updates.json (use release-artifacts)
        id: create_updates
        shell: bash
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG="${{ steps.version.outputs.tag }}"
          DATE=$(date -u +"%Y-%m-%dT%H:%M:%S.000Z")
          
          echo "ðŸš€ Creating updates.json using files in ./release-artifacts"
          echo "Contents of release-artifacts:"
          ls -la release-artifacts || true
          
          # Read the signature file we copied earlier (use step output if present)
          SIG_PATH="${{ steps.collect.outputs.sig }}"
          MSI_PATH="${{ steps.collect.outputs.msi }}"
          
          # Fallback to any file in release-artifacts
          if [ -z "$SIG_PATH" ]; then
            SIG_PATH=$(ls release-artifacts/*.msi.sig 2>/dev/null | head -n1 || true)
          fi
          if [ -z "$MSI_PATH" ]; then
            MSI_PATH=$(ls release-artifacts/*.msi 2>/dev/null | head -n1 || true)
          fi
          
          echo "DEBUG: Using SIG_PATH=$SIG_PATH"
          echo "DEBUG: Using MSI_PATH=$MSI_PATH"
          
          if [ -z "$SIG_PATH" ] || [ ! -f "$SIG_PATH" ]; then
            echo "âŒ No signature file found at $SIG_PATH"
            ls -la release-artifacts || true
            exit 1
          fi
          if [ -z "$MSI_PATH" ] || [ ! -f "$MSI_PATH" ]; then
            echo "âŒ No MSI file found at $MSI_PATH"
            ls -la release-artifacts || true
            exit 1
          fi
          
          SIGNATURE=$(cat "$SIG_PATH")
          MSI_FILENAME=$(basename "$MSI_PATH")
          
          cat > updates.json << EOF
          {
            "version": "$VERSION",
            "date": "$DATE",
            "platforms": {
              "windows-x86_64": {
                "signature": "$SIGNATURE",
                "url": "https://github.com/${{ github.repository }}/releases/download/$TAG/$MSI_FILENAME"
              }
            },
            "body": "See release notes at https://github.com/${{ github.repository }}/releases/tag/$TAG"
          }
          EOF
          
          echo "Created updates.json:"
          cat updates.json

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          name: Osskins ${{ steps.version.outputs.tag }}
          draft: false
          prerelease: false
          generate_release_notes: true
          files: |
            release-artifacts/*.msi
            release-artifacts/*.msi.sig
            updates.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-build-${{ steps.version.outputs.version }}
          path: |
            release-artifacts/*.msi
            release-artifacts/*.msi.sig
            updates.json
          retention-days: 30
