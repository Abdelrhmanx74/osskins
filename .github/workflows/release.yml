name: Build & Publish Updater Artifacts (Windows only)

on:
  push:
    tags:
      - 'v*'

jobs:
  create_release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      release_id: ${{ steps.create_release.outputs.id }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          release_name: Release ${{ github.ref_name }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build_and_upload:
    name: Build on Windows and upload artifacts
    needs: create_release
    runs-on: windows-latest
    env:
      RELEASE_TAG: ${{ github.ref_name }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8

      - name: Install dependencies
        shell: pwsh
        run: pnpm install

      - name: Build frontend
        shell: pwsh
        run: pnpm build

      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Build tauri bundle
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        shell: pwsh
        run: pnpm tauri build

      - name: Find Windows artifacts (exe/msi and .sig)
        id: find_all
        shell: pwsh
        run: |
          $root = "src-tauri\target\release\bundle"
          Write-Host "Searching under $root"
          $files = Get-ChildItem -Path $root -Recurse -File -ErrorAction SilentlyContinue |
            Where-Object { $_.Extension -in ".exe", ".msi", ".sig" }
          if (-not $files) { Write-Error "No artifacts found"; exit 1 }
          $list = $files | ForEach-Object { $_.FullName }
          $joined = ($list -join "`n")
          Write-Host "Artifacts:`n$joined"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "files<<EOF`n$joined`nEOF"

      - name: Upload all artifacts to release (exe/msi/sig)
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if (-not (Get-Command gh -ErrorAction SilentlyContinue)) {
            choco install gh -y | Out-Null
          }
          $files = "${{ steps.find_all.outputs.files }}".Split("`n") | Where-Object { $_ -ne "" }
          foreach ($f in $files) {
            Write-Host "Uploading $f"
            gh release upload "$env:RELEASE_TAG" "$f" --clobber
          }

  generate_metadata:
    name: Generate updates.json from Tauri .sig
    needs: [create_release, build_and_upload]
    runs-on: ubuntu-latest
    steps:
      - name: Install jq, curl
        run: |
          sudo apt-get update && sudo apt-get install -y jq curl

      - name: Build updates.json using uploaded assets and Tauri signatures
        env:
          REPO: ${{ github.repository }}
          RELEASE_ID: ${{ needs.create_release.outputs.release_id }}
          TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSION: ${{ github.ref_name }}
        run: |
          API="https://api.github.com/repos/$REPO/releases/$RELEASE_ID/assets"
          echo "Listing assets from $API"
          curl -s -H "Authorization: token $TOKEN" "$API" > /tmp/assets.json
          echo "Assets present:"
          jq -r '.[].name' /tmp/assets.json || true

          # Prefer an installer by extension (.exe, .msi, .AppImage, .tar.gz, .zip, .dmg)
          installer_url=$(jq -r '.[] | select(.name|test("\\.(exe|msi|AppImage|tar.gz|zip|dmg)$")) | .browser_download_url' /tmp/assets.json | head -n1)

          # If no installer found, try to match a .sig to a base name (e.g. foo.exe.sig -> foo.exe)
          if [ -z "$installer_url" ]; then
            sig_name=$(jq -r '.[] | select(.name|endswith(".sig")) | .name' /tmp/assets.json | head -n1)
            if [ -n "$sig_name" ]; then
              base_name="${sig_name%.sig}"
              echo "Found signature $sig_name; trying base $base_name"
              installer_url=$(jq -r --arg b "$base_name" '.[] | select(.name==$b) | .browser_download_url' /tmp/assets.json | head -n1)
            fi
          fi

          if [ -z "$installer_url" ]; then
            echo "No installer asset found in release. Available assets:"
            jq -r '.[].name' /tmp/assets.json || true
            echo ""
            echo "Make sure the Windows build job uploaded the installer (.exe or .msi) to the release. The job may have uploaded only the .sig."
            exit 1
          fi

          # Now find the matching signature asset for that installer
          installer_name=$(basename "$installer_url")
          sig_asset_name="${installer_name}.sig"
          sig_url=$(jq -r --arg n "$sig_asset_name" '.[] | select(.name==$n) | .browser_download_url' /tmp/assets.json | head -n1)

          # If signature not found by installer_name.sig, also try to find any .sig and use its content
          if [ -z "$sig_url" ]; then
            sig_url=$(jq -r '.[] | select(.name|endswith(".sig")) | .browser_download_url' /tmp/assets.json | head -n1)
            if [ -n "$sig_url" ]; then
              echo "Warning: exact matching .sig not found. Falling back to first .sig in release."
            fi
          fi

          if [ -z "$sig_url" ]; then
            echo "No .sig asset found in release. Available assets:"
            jq -r '.[].name' /tmp/assets.json || true
            exit 1
          fi

          echo "Using installer: $installer_name"
          echo "Installer URL: $installer_url"
          echo "Signature URL: $sig_url"

          curl -sL -H "Authorization: token $TOKEN" -o /tmp/installer.sig "$sig_url"
          if [ ! -s /tmp/installer.sig ]; then
            echo "Downloaded .sig is empty" >&2
            exit 1
          fi
          signature=$(tr -d '\r\n' < /tmp/installer.sig)

          # Use version without leading v
          ver="${VERSION#v}"
          now=$(date --utc +"%Y-%m-%dT%H:%M:%SZ")

          jq -n --arg v "$ver" --arg d "$now" --arg u "$installer_url" --arg s "$signature" \
            '{
              version:$v,
              pub_date:$d,
              platforms:{
                "windows-x86_64": {
                  url:$u,
                  signature:$s
                }
              }
            }' > updates.json

          cat updates.json

      - name: Upload updates.json to release
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create_release.outputs.upload_url }}
          asset_path: updates.json
          asset_name: updates.json
          asset_content_type: application/json
