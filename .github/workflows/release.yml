# Build & Publish Tauri Windows Release (with updater JSON)
# NOTE: replace placeholders and ensure the secrets TAURI_SIGNING_PRIVATE_KEY and
# TAURI_SIGNING_PRIVATE_KEY_PASSWORD are configured in the repo settings.
name: Build & Publish Tauri Windows Release (with updater JSON)

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  build_and_release:
    name: Build on Windows and create Release via tauri-action
    runs-on: windows-latest
    env:
      TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
      TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout repository (with submodules)
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          pnpm-version: 8

      - name: Install frontend deps
        shell: pwsh
        run: pnpm install

      - name: Build frontend
        shell: pwsh
        run: pnpm build

      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Run tauri-action (build & release)
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          tagName: ${{ github.ref_name }}
          releaseName: 'Osskins ${{ github.ref_name }}'
          releaseBody: 'Release built by CI (tauri-action).'
          releaseDraft: false
          prerelease: false
          args: ''

  generate_updates_json:
    name: Generate static updates.json from uploaded release assets
    runs-on: ubuntu-latest
    needs: build_and_release
    env:
      REPO: ${{ github.repository }}
      TOKEN: ${{ secrets.GITHUB_TOKEN }}
      VERSION: ${{ github.ref_name }}
    steps:
      - name: Install jq & curl
        run: sudo apt-get update && sudo apt-get install -y jq curl

      - name: Lookup release by tag
        run: |
          TAG=${GITHUB_REF##*/}
          echo "Looking up release for tag $TAG"
          API="https://api.github.com/repos/${REPO}/releases/tags/${TAG}"
          curl -s -H "Authorization: token ${TOKEN}" "$API" > /tmp/release.json
          if [ ! -s /tmp/release.json ]; then
            echo "/tmp/release.json is empty; release lookup failed" >&2
            jq -C . /tmp/release.json || true
            exit 1
          fi
          echo "Release found:"
          jq -r '.name, .id, .tag_name' /tmp/release.json || true
          jq -r '.assets[].name' /tmp/release.json || true

      - name: Choose installer asset + matching .sig
        id: pick
        run: |
          # Prefer NSIS .exe, fallback to MSI
          installer=$(jq -r '.assets[] | select(.name|endswith(".exe")) | .name' /tmp/release.json | head -n1)
          if [ -z "$installer" ]; then
            installer=$(jq -r '.assets[] | select(.name|endswith(".msi")) | .name' /tmp/release.json | head -n1)
          fi
          if [ -z "$installer" ]; then
            echo "No installer (.exe or .msi) found in release assets" >&2
            jq -r '.assets[].name' /tmp/release.json >&2 || true
            exit 1
          fi
          # signature file is installer + ".sig"
          sig_name="${installer}.sig"
          echo "installer=$installer" >> $GITHUB_OUTPUT
          echo "sig_name=$sig_name" >> $GITHUB_OUTPUT

      - name: Fetch asset URLs and signature content, build updates.json
        env:
          TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          installer="${{ steps.pick.outputs.installer }}"
          sig_name="${{ steps.pick.outputs.sig_name }}"
          echo "Selected installer: $installer"
          installer_url=$(jq -r --arg n "$installer" '.assets[] | select(.name==$n) | .browser_download_url' /tmp/release.json)
          sig_url=$(jq -r --arg n "$sig_name" '.assets[] | select(.name==$n) | .browser_download_url' /tmp/release.json)

          if [ -z "$installer_url" ] || [ -z "$sig_url" ]; then
            echo "Installer or its .sig not found among release assets:" >&2
            jq -r '.assets[].name' /tmp/release.json >&2 || true
            echo "installer_url: $installer_url" >&2
            echo "sig_url: $sig_url" >&2
            exit 1
          fi

          # Download the .sig and trim newlines (Tauri expects raw signature content)
          curl -sL -H "Authorization: token $TOKEN" -o /tmp/installer.sig "$sig_url"
          if [ ! -s /tmp/installer.sig ]; then
            echo "Downloaded .sig is empty" >&2
            exit 1
          fi
          signature=$(tr -d '\r\n' < /tmp/installer.sig)

          # Use version without leading v
          ver="${VERSION#v}"
          now=$(date --utc +"%Y-%m-%dT%H:%M:%SZ")

          cat > updates.json <<EOF
{
  "version": "$ver",
  "pub_date": "$now",
  "platforms": {
    "windows-x86_64": {
      "url": "$installer_url",
      "signature": "$signature"
    }
  }
}
EOF
          echo "Built updates.json:"
          cat updates.json

      - name: Upload updates.json to release via GitHub uploads API
        env:
          TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          upload_url_template=$(jq -r .upload_url /tmp/release.json)
          # strip template suffix like {?name,label}
          upload_url="${upload_url_template%\{*}"
          echo "Uploading updates.json to $upload_url?name=updates.json"
          response=$(curl -sSL -X POST -H "Authorization: token $TOKEN" \
            -H "Content-Type: application/json" --data-binary @updates.json \
            "$upload_url?name=updates.json")
          echo "Upload response summary:"
          echo "$response" | jq -r '.url, .state, .browser_download_url' || echo "$response"
