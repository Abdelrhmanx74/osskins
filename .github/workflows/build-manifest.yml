name: Build and publish lol-skins manifest

on:
  workflow_dispatch:
  schedule:
    - cron: "0 */6 * * *" # every 6 hours

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Prepare environment
        run: |
          sudo apt-get update
          sudo apt-get install -y jq coreutils git curl python3

      - name: Configure git user
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Clone this repository (app)
        run: |
          git clone --depth=1 "https://github.com/${{ github.repository }}.git" app
          mkdir -p app/tmp

      - name: Fetch external releases info (always)
        id: fetch_releases
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TMP_RELEASES="app/tmp/external_releases.json"
          REPO="LeagueToolkit/cslol-manager"
          API_URL="https://api.github.com/repos/${REPO}/releases/latest"

          # Auth when available to avoid strict rate limits
          if [ -n "${GH_TOKEN:-}" ]; then
            release_json="$(curl -sS -H 'Accept: application/vnd.github+json' -H "Authorization: Bearer ${GH_TOKEN}" "${API_URL}" || true)"
          else
            release_json="$(curl -sS -H 'Accept: application/vnd.github+json' "${API_URL}" || true)"
          fi

          # Parse tag and detect test/dev suffix
          tag="$(echo "${release_json}" | jq -r '.tag_name // empty')"
          IS_TEST=false
          if [ -n "$tag" ] && echo "$tag" | grep -q -- '-test$'; then
            IS_TEST=true
          fi
          echo "Fetched release tag: ${tag:-<none>} (is_test=${IS_TEST})"

          # Choose primary asset: prefer cslol-manager.zip, fallback to first asset
          asset_name="$(echo "${release_json}" | jq -r '.assets[]? | select(.name=="cslol-manager.zip") | .name' | head -n1)"
          if [ -z "${asset_name}" ]; then
            asset_name="$(echo "${release_json}" | jq -r '.assets[0]?.name // empty')"
          fi
          asset_url="$(echo "${release_json}" | jq -r '.assets[]? | select(.name=="cslol-manager.zip") | .browser_download_url' | head -n1)"
          if [ -z "${asset_url}" ]; then
            asset_url="$(echo "${release_json}" | jq -r '.assets[0]?.browser_download_url // empty')"
          fi

          asset_size_raw="$(echo "${release_json}" | jq -r '.assets[]? | select(.name=="cslol-manager.zip") | .size' | head -n1)"
          if [ -z "${asset_size_raw}" ] || ! [[ "${asset_size_raw}" =~ ^[0-9]+$ ]]; then
            asset_size_raw=0
          fi

          # If we have an asset URL, attempt to download to compute sha256 and size.
          sig_b64=""
          sha256=""
          size=0
          if [ -n "${asset_url}" ]; then
            mkdir -p app/tmp/assetfiles
            outpath="app/tmp/assetfiles/${asset_name}"
            echo "Downloading asset ${asset_name}..."
            if [ -n "${GH_TOKEN:-}" ]; then
              curl -sL -H "Authorization: token ${GH_TOKEN}" -o "${outpath}" "${asset_url}"
            else
              curl -sL -o "${outpath}" "${asset_url}"
            fi

            if [ -f "${outpath}" ]; then
              sha256="$(sha256sum "${outpath}" | awk '{print $1}')"
              size="$(stat -c%s "${outpath}" 2>/dev/null || stat -f%z "${outpath}" 2>/dev/null || echo 0)"
            fi

            # Try to find a signature asset next to the main asset (asset_name + .sig)
            sig_url="$(echo "${release_json}" | jq -r --arg sname "${asset_name}.sig" '.assets[]? | select(.name==$sname) | .browser_download_url' | head -n1 || true)"
            if [ -n "${sig_url}" ]; then
              echo "Found signature asset, downloading..."
              if [ -n "${GH_TOKEN:-}" ]; then
                sig_contents="$(curl -sL -H "Authorization: token ${GH_TOKEN}" "${sig_url}")"
              else
                sig_contents="$(curl -sL "${sig_url}")"
              fi
              # base64-encode the signature file for embedding in JSON (portable)
              sig_b64="$(printf "%s" "$sig_contents" | python3 -c 'import sys,base64; data=sys.stdin.buffer.read(); print(base64.b64encode(data).decode())')"
            else
              # No .sig asset present
              sig_b64=""
              if [ "${IS_TEST}" = false ]; then
                echo "Warning: no signature asset (${asset_name}.sig) found for release ${tag}. This is allowed but signature will be empty in manifest."
              else
                echo "Test release: no signature required for ${asset_name}."
              fi
            fi
          else
            echo "No asset URL found for release ${tag}; writing empty external_releases entry."
          fi

          # Write JSON array ([] if missing)
          jq -n \
            --arg repo "${REPO}" \
            --arg tag "${tag}" \
            --arg asset_name "${asset_name}" \
            --arg url "${asset_url}" \
            --arg sha256 "${sha256:-}" \
            --arg sig "${sig_b64:-}" \
            --argjson size "${size:-0}" \
            'if ($tag != "" and $url != "") then
               [{repo:$repo, tag_name:$tag, asset_name:$asset_name, browser_download_url:$url, size:$size, sha256:$sha256, signature:$sig}]
             else
               []
             end' > "${TMP_RELEASES}"

          echo "external_releases written to ${TMP_RELEASES}"

      - name: Check upstream commit and skip build if unchanged
        id: check_upstream
        run: |
          set -euo pipefail
          current_commit=""
          if [ -f app/docs/manifest.json ]; then
            current_commit=$(jq -r '.source_repo' app/docs/manifest.json 2>/dev/null | sed -E 's/.*@(.+)$/\1/' || true)
          fi
          remote_commit=$(git ls-remote https://github.com/darkseal-org/lol-skins.git refs/heads/main | cut -f1 || true)
          echo "current_commit=${current_commit} remote_commit=${remote_commit}"
          if [ -n "$current_commit" ] && [ "$current_commit" = "$remote_commit" ]; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "No upstream changes (manifest already at ${current_commit})."
          else
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Clone upstream lol-skins
        if: steps.check_upstream.outputs.changed == 'true'
        run: |
          git clone --depth=1 --no-single-branch https://github.com/darkseal-org/lol-skins.git upstream

      - name: Generate manifest.json (stream items to temp file)
        if: steps.check_upstream.outputs.changed == 'true'
        run: |
          set -euo pipefail
          cd upstream
          SRC_SHA=$(git rev-parse HEAD)
          SRC_BRANCH="main"

          TMP_ITEMS="$(mktemp)"
          echo "[" > "${TMP_ITEMS}"
          first=true

          while IFS= read -r f; do
            size=$(stat -c%s "$f")
            sha256=$(sha256sum "$f" | cut -d' ' -f1)
            last_commit=$(git log -1 --format=%H -- "$f")
            url="https://raw.githubusercontent.com/darkseal-org/lol-skins/${SRC_BRANCH}/${f}"
            obj=$(jq -n --arg path "$f" --arg url "$url" --arg size "$size" --arg sha "$sha256" --arg commit "$last_commit" \
              '{path:$path, url:$url, size: ($size|tonumber), sha256:$sha, commit:$commit}')
            if [ "$first" = true ]; then
              echo "$obj" >> "${TMP_ITEMS}"
              first=false
            else
              echo ",$obj" >> "${TMP_ITEMS}"
            fi
          done < <(git ls-files | grep -E '\.(zip|fantome)$' || true)

          echo "]" >> "${TMP_ITEMS}"

          cd ../app
          mkdir -p docs

          # Build final manifest including external_releases
          jq -n --slurpfile items "${TMP_ITEMS}" --slurpfile releases "tmp/external_releases.json" \
            --arg gen "$(date -u +%FT%TZ)" \
            --arg repo "darkseal-org/lol-skins@${SRC_SHA}" \
            --arg branch "${SRC_BRANCH}" \
            --arg license_url "https://github.com/darkseal-org/lol-skins/blob/main/LICENSE" \
            --arg source_url "https://github.com/darkseal-org/lol-skins" \
            --arg attribution "Skins Â© their respective creators. DSCL license applies. Not affiliated with or endorsed by Dark Seal or Riot Games." \
            '{schema:1, generated_at:$gen, source_repo:$repo, branch:$branch, license:$license_url, source:$source_url, attribution:$attribution, items: $items[0], external_releases: $releases[0] }' \
            > docs/manifest.json

          rm -f "${TMP_ITEMS}"

      - name: Merge external_releases into existing manifest (if upstream unchanged)
        if: steps.check_upstream.outputs.changed == 'false'
        run: |
          set -euo pipefail
          cd app
          if [ ! -f docs/manifest.json ]; then
            echo "No existing manifest.json found; nothing to merge."
            exit 0
          fi
          RELEASES_FILE="tmp/external_releases.json"
          jq --slurpfile releases "${RELEASES_FILE}" \
            '. + { external_releases: ($releases[0] // []) }' \
            docs/manifest.json > docs/manifest.new.json
          mv docs/manifest.new.json docs/manifest.json

      - name: Commit and push manifest (if changed) (upstream changed)
        if: steps.check_upstream.outputs.changed == 'true'
        env:
          GHTOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          cd app
          git remote set-url origin "https://x-access-token:${GHTOKEN}@github.com/${{ github.repository }}.git"
          git add docs/manifest.json || true
          if git diff --staged --quiet; then
            echo "No changes to manifest.json"
          else
            git commit -m "chore: update lol-skins manifest"
            git push origin HEAD:main
          fi

      - name: Commit and push manifest (if changed) (upstream unchanged - external_releases)
        if: steps.check_upstream.outputs.changed == 'false'
        env:
          GHTOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          cd app
          git remote set-url origin "https://x-access-token:${GHTOKEN}@github.com/${{ github.repository }}.git"
          git add docs/manifest.json || true
          if git diff --staged --quiet; then
            echo "No changes to manifest.json (external_releases unchanged)"
          else
            git commit -m "chore: update external_releases in manifest"
            git push origin HEAD:main
          fi
