name: Build and publish lol-skins manifest (v2)

on:
  workflow_dispatch:
  schedule:
    - cron: "0 */6 * * *"

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Prepare environment
        run: |
          sudo apt-get update
          sudo apt-get install -y jq coreutils git curl
      
      - name: Configure git user
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
      
      - name: Clone this repository (app)
        run: |
          git clone --depth=1 "https://github.com/${{ github.repository }}.git" app
          mkdir -p app/tmp
      
      - name: Fetch external releases info (always)
        id: fetch_releases
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TMP_RELEASES="app/tmp/external_releases.json"
          REPO="LeagueToolkit/cslol-manager"
          
          echo "Fetching latest release for $REPO..."
          RELEASE_JSON=$(gh release view --repo "$REPO" --json tagName,assets)
          
          TAG_NAME=$(echo "$RELEASE_JSON" | jq -r '.tagName')
          ASSET=$(echo "$RELEASE_JSON" | jq -r '.assets[] | select(.name | endswith(".zip")) | select(.name | contains("cslol-manager")) | .')
          
          if [ -z "$ASSET" ] || [ "$ASSET" = "null" ]; then
            echo "Error: Could not find cslol-manager zip asset"
            exit 1
          fi
          
          ASSET_NAME=$(echo "$ASSET" | jq -r '.name')
          DOWNLOAD_URL=$(echo "$ASSET" | jq -r '.url')
          SIZE=$(echo "$ASSET" | jq -r '.size')
          
          jq -n --arg repo "$REPO" \
                --arg tag "$TAG_NAME" \
                --arg name "$ASSET_NAME" \
                --arg url "$DOWNLOAD_URL" \
                --argjson size "$SIZE" \
                '[{
                  "repo": $repo,
                  "tag_name": $tag,
                  "asset_name": $name,
                  "browser_download_url": $url,
                  "size": $size
                }]' > "$TMP_RELEASES"
          
          echo "External releases saved to $TMP_RELEASES"
      
      - name: Check upstream commit and skip build if unchanged
        id: check_upstream
        run: |
          set -euo pipefail
          current_commit=""
          if [ -f app/docs/manifest.json ]; then
            current_commit=$(jq -r '.source_repo' app/docs/manifest.json 2>/dev/null | sed -E 's/.*@(.+)$/\\1/' || true)
          fi
          remote_commit=$(git ls-remote https://github.com/darkseal-org/lol-skins.git refs/heads/main | cut -f1 || true)
          echo "current_commit=${current_commit} remote_commit=${remote_commit}"
          if [ -n "$current_commit" ] && [ "$current_commit" = "$remote_commit" ]; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "No upstream changes (manifest already at ${current_commit})."
          else
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Clone upstream lol-skins
        if: steps.check_upstream.outputs.changed == 'true'
        run: |
          git clone --depth=1 --no-single-branch https://github.com/darkseal-org/lol-skins.git upstream

      - name: Generate v2 manifest.json (champion grouped)
        if: steps.check_upstream.outputs.changed == 'true'
        run: |
          set -euo pipefail
          cd upstream
          SRC_SHA=$(git rev-parse HEAD)
          SRC_BRANCH="main"

          # Gather files
          FILES_JSON=$(mktemp)
          git ls-files | grep -E '\\.(zip|fantome)$' | jq -R -s -c 'split("\\n") | map(select(length>0))' > "$FILES_JSON"

          # Build raw items with url/size/sha/commit
          ITEMS_JSON=$(mktemp)
          jq -r '.[]' "$FILES_JSON" | while read -r f; do
            size=$(stat -c%s "$f")
            sha256=$(sha256sum "$f" | cut -d' ' -f1)
            last_commit=$(git log -1 --format=%H -- "$f")
            url="https://raw.githubusercontent.com/darkseal-org/lol-skins/${SRC_BRANCH}/$f"
            jq -n --arg path "$f" --arg url "$url" --arg size "$size" --arg sha "$sha256" --arg commit "$last_commit" \
              '{path:$path, url:$url, size: ($size|tonumber), sha256:$sha, commit:$commit}' >> "$ITEMS_JSON"
          done

          # Group by champion folder (second segment under skins/)
          CHAMPS_JSON=$(mktemp)
          jq -cs 'group_by(.path | split("/")[1]) | map({
             key: (.[0].path | split("/")[1] | ascii_downcase | gsub("['’`]|[^a-z0-9]"; "") ),
             name: (.[0].path | split("/")[1]),
             assets: {
               skins: [ .[] | select( (.path | split("/") | length) >= 3 and ((.path | split("/")[2] // "") | ascii_downcase) != "chromas") | {key: ((.path | split("/") | last | sub("\\\\.zip$"; "") ) | ascii_downcase | gsub("['’`]|[^a-z0-9]"; "")), name: (.path | split("/") | last | sub("\\\\.zip$"; "")), url, size, sha256, commit} ],
               chromas: [ .[] | select( (.path | split("/") | length) >= 4 and ((.path | split("/")[2] // "") | ascii_downcase) == "chromas") | {key: ((.path | split("/") | last | sub("\\\\.zip$"; "") ) | ascii_downcase | gsub("['’`]|[^a-z0-9]"; "")), name: (.path | split("/") | last | sub("\\\\.zip$"; "")), url, size, sha256, commit} ]
             }
           } | . + { size: ( (.[].size) // 0 | tonumber ) } )' "$ITEMS_JSON" > "$CHAMPS_JSON"

          # Compute fingerprint per champion (sha256 of sorted asset sha256 values)
          CHAMPS_FP_JSON=$(mktemp)
          jq -c '.[]' "$CHAMPS_JSON" | while read -r champ; do
            sha_list=$(echo "$champ" | jq -r '[ (.assets.skins // [])[], (.assets.chromas // [])[] ] | map(.sha256) | .[]')
            sorted=$(printf "%s\\n" $sha_list | sort | tr '\\n' ':' | sed 's/:$//')
            fp=$(printf "%s" "$sorted" | sha256sum | awk '{print $1}')
            echo "$champ" | jq --arg fp "$fp" '. + { fingerprint: $fp }' >> "$CHAMPS_FP_JSON"
          done
          mv "$CHAMPS_FP_JSON" "$CHAMPS_JSON"

          cd ../app
          mkdir -p docs

          # Build final manifest v2
          jq -n \
            --arg gen "$(date -u +%FT%TZ)" \
            --arg repo "darkseal-org/lol-skins@${SRC_SHA}" \
            --arg branch "${SRC_BRANCH}" \
            --arg license_url "https://github.com/darkseal-org/lol-skins/blob/main/LICENSE" \
            --arg source_url "https://github.com/darkseal-org/lol-skins" \
            --arg attribution "Skins © their respective creators. DSCL license applies. Not affiliated with or endorsed by Dark Seal or Riot Games." \
            --slurpfile champions "$CHAMPS_JSON" \
            --slurpfile releases "../app/tmp/external_releases.json" \
            '{schema:2, generated_at:$gen, source_repo:$repo, branch:$branch, license:$license_url, source:$source_url, attribution:$attribution, champions: $champions[0], external_releases: ($releases[0] // []) }' \
            > docs/manifest.json

      - name: Merge external_releases into existing manifest (if upstream unchanged)
        if: steps.check_upstream.outputs.changed == 'false'
        run: |
          set -euo pipefail
          cd app
          if [ ! -f docs/manifest.json ]; then
            echo "No existing manifest.json found; nothing to merge."
            exit 0
          fi
          RELEASES_FILE="tmp/external_releases.json"
          jq --slurpfile releases "${RELEASES_FILE}" \
            '. + { external_releases: ($releases[0] // []) }' \
            docs/manifest.json > docs/manifest.new.json
          mv docs/manifest.new.json docs/manifest.json
      
      - name: Commit and push manifest
        run: |
          cd app
          git add public/manifest.json
          
          if git diff --staged --quiet; then
            echo "No changes to manifest"
            exit 0
          fi
          
          git commit -m "chore: update lol-skins manifest v2 [skip ci]"
          git push origin HEAD:gh-pages || {
            echo "Creating gh-pages branch..."
            git checkout -b gh-pages
            git push origin gh-pages
          }
