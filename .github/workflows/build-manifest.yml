name: Build and publish data manifest

on:
  workflow_dispatch:
  schedule:
    - cron: "0 */6 * * *"

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository (will be used to commit docs/)
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
          persist-credentials: true

      - name: Prepare environment
        run: |
          sudo apt-get update
          sudo apt-get install -y jq coreutils git curl gh
          # ensure sha256sum is available (coreutils)

      - name: Configure git user
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Ensure directories exist
        run: |
          mkdir -p app/tmp app/docs docs

      - name: Fetch external releases info (latest → previous fallback)
        id: fetch_releases
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RECENT_LIMIT: 50
        run: |
          set -euo pipefail

          TMP_RELEASES="app/tmp/external_releases.json"
          REPO="LeagueToolkit/cslol-manager"
          mkdir -p "$(dirname "$TMP_RELEASES")"

          echo "Attempting to find a cslol-manager archive asset in the latest release first..."
          export GITHUB_TOKEN="${GH_TOKEN}"

          # Helper to extract a matching asset (base64 JSON) from a release JSON blob
          find_asset_b64_from_release_json() {
            local rel_json="$1"
            # asset name must contain cslol or cslol-manager (allow - or _), and end with a common archive extension
            echo "$rel_json" | jq -c -r --arg re 'cslol[-_]?manager|cslol' --arg ex 'zip|exe|7z|tar\\.gz|msi' \
              '.assets[]? | select(.name | test($re + ".*\\.(" + $ex + ")$"; "i")) | @base64' || true
          }

          selected_tag=""
          selected_asset_b64=""

          # 1) Try the latest release (gh release view without --tag returns latest)
          if RELEASE_JSON=$(gh release view --repo "$REPO" --json tagName,assets 2>/dev/null); then
            echo "Got latest release: $(echo "$RELEASE_JSON" | jq -r '.tagName // "(unknown)")')"
            selected_asset_b64=$(find_asset_b64_from_release_json "$RELEASE_JSON" | head -n1 || true)
            if [ -n "$selected_asset_b64" ]; then
              selected_tag=$(echo "$RELEASE_JSON" | jq -r '.tagName // ""')
            fi
          else
            echo "Latest release view failed (maybe 404 or no releases). Will fall back to scanning recent releases."
          fi

          # 2) If not found, iterate recent releases (newest→oldest) and pick first with a matching asset
          if [ -z "${selected_asset_b64}" ]; then
            echo "Scanning up to ${RECENT_LIMIT} recent releases for a matching asset..."
            if ! RELEASES_LIST_JSON=$(gh release list --repo "$REPO" --limit "${RECENT_LIMIT}" --json tagName,publishedAt 2>/dev/null); then
              echo "gh release list failed or no releases; writing empty external_releases.json"
              jq -n '[]' > "$TMP_RELEASES"
              echo "selected_tag=" >> $GITHUB_OUTPUT
              echo "selected_asset_name=" >> $GITHUB_OUTPUT
              exit 0
            fi

            # build array of tags preserving order (newest first)
            mapfile -t tags < <(echo "$RELEASES_LIST_JSON" | jq -r '.[].tagName')

            for tag in "${tags[@]}"; do
              echo "Trying release tag: $tag"
              if rel_json=$(gh release view --repo "$REPO" --tag "$tag" --json tagName,assets 2>/dev/null); then
                asset_b64=$(find_asset_b64_from_release_json "$rel_json" | head -n1 || true)
                if [ -n "$asset_b64" ]; then
                  selected_tag="$tag"
                  selected_asset_b64="$asset_b64"
                  break
                fi
              else
                echo "  release view for $tag failed (skipping)"
              fi
            done
          fi

          # 3) If we still have nothing, write an empty releases array and exit gracefully
          if [ -z "$selected_asset_b64" ]; then
            echo "::warning::No suitable cslol-manager archive found in any release; writing empty external_releases.json"
            jq -n '[]' > "$TMP_RELEASES"
            echo "selected_tag=" >> $GITHUB_OUTPUT
            echo "selected_asset_name=" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Decode the selected asset and emit outputs
          asset_name=$(echo "$selected_asset_b64" | base64 -d | jq -r '.name // "(unnamed)"')
          download_url=$(echo "$selected_asset_b64" | base64 -d | jq -r '.browser_download_url // ""')
          size=$(echo "$selected_asset_b64" | base64 -d | jq -r '.size // 0')
          echo "selected_tag=${selected_tag}" >> $GITHUB_OUTPUT
          echo "selected_asset_name=${asset_name}" >> $GITHUB_OUTPUT
          echo "Selected: tag=${selected_tag}, asset=${asset_name}, url=${download_url}, size=${size}"

          # Build a single-element array for external_releases
          jq -n \
            --arg name "cslol-manager" \
            --arg tag "$selected_tag" \
            --arg asset "$asset_name" \
            --arg url "$download_url" \
            --argjson size "$size" \
            '[{ name:$name, tag:$tag, asset:$asset, url:$url, size:$size }]' \
            > "$TMP_RELEASES"

          echo "external_releases.json written successfully."

      - name: Check LeagueSkins commit and compute changes
        id: check_upstream
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          
          # Get current manifest from our repo
          current_commit=""
          previous_commit=""
          REMOTE_MANIFEST_URL="https://raw.githubusercontent.com/${{ github.repository }}/main/docs/manifest.json"
          
          if curl --output /dev/null --silent --head --fail "$REMOTE_MANIFEST_URL"; then
            EXISTING_MANIFEST=$(curl -s "$REMOTE_MANIFEST_URL")
            current_commit=$(echo "$EXISTING_MANIFEST" | jq -r '.source_commit // ""' 2>/dev/null || true)
            previous_commit=$(echo "$EXISTING_MANIFEST" | jq -r '.previous_commit // ""' 2>/dev/null || true)
          fi

          # Get latest commit from LeagueSkins
          remote_commit=$(git ls-remote https://github.com/Alban1911/LeagueSkins.git refs/heads/main | cut -f1 || true)
          echo "current_commit=${current_commit} remote_commit=${remote_commit}"
          echo "SRC_SHA=${remote_commit}" >> $GITHUB_ENV
          echo "PREV_SHA=${current_commit}" >> $GITHUB_ENV

          if [ -n "$current_commit" ] && [ "$current_commit" = "$remote_commit" ]; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "No upstream changes (manifest already at ${current_commit})."
          else
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "Changes detected: ${current_commit:-none} -> ${remote_commit}"
          fi

      - name: Compute changed champions between commits
        id: compute_changes
        if: steps.check_upstream.outputs.changed == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          
          CHANGES_FILE="app/tmp/changed_champions.json"
          mkdir -p app/tmp
          
          # If no previous commit, mark as full update
          if [ -z "${PREV_SHA}" ] || [ "${PREV_SHA}" = "null" ]; then
            echo '{"type": "full", "champions": []}' > "$CHANGES_FILE"
            echo "No previous commit - full update required"
            exit 0
          fi
          
          echo "Computing changes between ${PREV_SHA} and ${SRC_SHA}..."
          
          # Use GitHub compare API to get changed files
          COMPARE_URL="https://api.github.com/repos/Alban1911/LeagueSkins/compare/${PREV_SHA}...${SRC_SHA}"
          
          COMPARE_RESULT=$(curl -s -H "Authorization: token ${GH_TOKEN}" \
            -H "Accept: application/vnd.github.v3+json" \
            "$COMPARE_URL" || echo '{"files": []}')
          
          # Extract changed champion IDs from file paths
          # File paths look like: skins/{champion_id}/{skin_id}/{skin_id}.zip
          CHANGED_CHAMPIONS=$(echo "$COMPARE_RESULT" | jq -r '
            [.files[]? | 
              select(.filename | startswith("skins/")) |
              .filename | 
              split("/") | 
              select(length >= 2) |
              .[1] |
              select(. != "" and . != null) |
              tonumber
            ] | unique | sort
          ' 2>/dev/null || echo '[]')
          
          # Count changes
          NUM_CHANGES=$(echo "$CHANGED_CHAMPIONS" | jq 'length')
          echo "Found ${NUM_CHANGES} changed champions"
          
          # Build the changes object
          jq -n \
            --argjson champions "$CHANGED_CHAMPIONS" \
            --arg prev "${PREV_SHA}" \
            --arg curr "${SRC_SHA}" \
            '{
              type: "incremental",
              previous_commit: $prev,
              current_commit: $curr,
              champions: $champions
            }' > "$CHANGES_FILE"
          
          echo "Changes computed and saved to $CHANGES_FILE"
          cat "$CHANGES_FILE"

      - name: Build updated manifest with change tracking
        if: steps.check_upstream.outputs.changed == 'true'
        run: |
          set -euo pipefail

          RELEASES_FILE="app/tmp/external_releases.json"
          CHANGES_FILE="app/tmp/changed_champions.json"
          mkdir -p app/docs app/tmp

          if [ ! -f "$RELEASES_FILE" ]; then
            jq -n '[]' > "$RELEASES_FILE"
          fi
          
          if [ ! -f "$CHANGES_FILE" ]; then
            jq -n '{"type": "full", "champions": []}' > "$CHANGES_FILE"
          fi

          # Build manifest with change tracking
          # This allows the app to fetch just this manifest and know exactly what changed
          jq -n \
            --arg gen "$(date -u +%FT%TZ)" \
            --arg commit "${SRC_SHA}" \
            --arg prev_commit "${PREV_SHA:-}" \
            --arg branch "main" \
            --arg license_url "https://github.com/Alban1911/LeagueSkins/blob/main/LICENSE" \
            --arg source_url "https://github.com/Alban1911/LeagueSkins" \
            --arg attribution "Skins © their respective creators. Not affiliated with or endorsed by Riot Games." \
            --slurpfile releases "${RELEASES_FILE}" \
            --slurpfile changes "${CHANGES_FILE}" \
            '{
              schema: 4,
              generated_at: $gen,
              source_commit: $commit,
              previous_commit: (if $prev_commit == "" then null else $prev_commit end),
              branch: $branch,
              license: $license_url,
              source: $source_url,
              attribution: $attribution,
              changes: ($changes[0] // {type: "full", champions: []}),
              external_releases: ($releases[0] // [])
            }' \
            > app/docs/manifest.json
          
          echo "Manifest built successfully:"
          cat app/docs/manifest.json

      - name: Merge external_releases into existing manifest (if upstream unchanged)
        if: steps.check_upstream.outputs.changed == 'false'
        run: |
          set -euo pipefail
          mkdir -p app/tmp app/docs

          EXISTING_TMP="app/tmp/existing_manifest.json"
          if curl -s "https://raw.githubusercontent.com/${{ github.repository }}/main/docs/manifest.json" > "$EXISTING_TMP"; then
            echo "Fetched existing main:/docs/manifest.json into $EXISTING_TMP"
          else
            echo "{}" > "$EXISTING_TMP"
            echo "No existing manifest found — starting from empty manifest"
          fi

          RELEASES_FILE="app/tmp/external_releases.json"
          if [ ! -f "$RELEASES_FILE" ]; then
            jq -n '[]' > "$RELEASES_FILE"
          fi

          # Merge releases into the existing manifest, preserve change tracking
          jq --slurpfile releases "${RELEASES_FILE}" \
             '. + { external_releases: ($releases[0] // []) }' \
             "$EXISTING_TMP" > app/docs/manifest.json

      - name: Deploy only docs/ to main (non-destructive)
        run: |
          set -euo pipefail
          git checkout main
          mkdir -p docs

          if [ -f app/docs/manifest.json ]; then
            cp app/docs/manifest.json docs/manifest.json
          else
            jq -n '{schema:4, generated_at: ("'$(date -u +%FT%TZ)'"), external_releases: [] }' > docs/manifest.json
          fi

          cat > docs/index.html << 'EOF'
<!doctype html>
<html>
  <head><meta charset="utf-8"><title>OSS Kins Manifest</title></head>
  <body>
    <h1>OSS Kins Manifest</h1>
    <p>The manifest is available at <a href="./manifest.json">manifest.json</a></p>
    <p>Skins are downloaded directly from <a href="https://github.com/Alban1911/LeagueSkins">LeagueSkins</a> using ID-based paths.</p>
    <h2>Schema v4 Features</h2>
    <ul>
      <li><code>source_commit</code> - Current LeagueSkins commit SHA</li>
      <li><code>previous_commit</code> - Previous manifest commit (for delta tracking)</li>
      <li><code>changes</code> - Object containing changed champion IDs since last update</li>
      <li><code>external_releases</code> - cslol-manager release info</li>
    </ul>
  </body>
</html>
EOF

          touch docs/.nojekyll

          git add docs/manifest.json docs/index.html docs/.nojekyll

          if git diff --cached --quiet; then
            echo "No docs changes to commit."
          else
            git commit -m "Update docs (manifest) [skip ci]"
            git push origin main
          fi
